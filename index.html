<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Special Probability Model</title>
<style>
body{font-family:Arial;padding:20px}
button{padding:6px 12px;margin:5px}
.prob{font-size:22px;font-weight:bold}
.hot{color:red}
.warm{color:orange}
.cold{color:#1e90ff}
</style>
</head>
<body>

<h2>特殊機率模型</h2>

<button onclick="addRandom()">新增隨機一局</button>

<p>特殊機率：<span id="specialProb" class="prob cold">0%</span></p>
<p id="gapInfo"></p>
<p id="gapHistory"></p>

<script>

const BASE_SPECIAL=0.05;

let rounds=[];
let specialIntervals=[];
let specialProbs=[];

// ==============================
// 工具函式
// ==============================

function getGap(){
  for(let i=rounds.length-1;i>=0;i--){
    if(rounds[i].isSpecial){
      return rounds.length-1-i;
    }
  }
  return rounds.length;
}

function analyzeRound(r){
  const arr=[r.d1,r.d2,r.d3];
  const count={};
  arr.forEach(n=>count[n]=(count[n]||0)+1);
  const values=Object.values(count);

  if(values.includes(3)) return 3;
  if(values.includes(2)) return 2;
  return 1;
}

// ==============================
// 大小趨勢模型（結構強度）
// ==============================

function analyzeBigSmallTrend(){

  const last10=rounds.slice(-10);
  if(last10.length<6) return 1;

  const seq=last10.map(r=>r.total>=11?1:0);

  let trendScore=1;

  // 最大連續壓制
  let maxRun=1;
  let run=1;
  for(let i=1;i<seq.length;i++){
    if(seq[i]===seq[i-1]){
      run++;
      maxRun=Math.max(maxRun,run);
    }else{
      run=1;
    }
  }

  if(maxRun>=4){
    trendScore+=0.6;
  }

  // 高頻交錯
  let flipCount=0;
  for(let i=1;i<seq.length;i++){
    if(seq[i]!==seq[i-1]) flipCount++;
  }

  if(flipCount>=6){
    trendScore+=0.45;
  }

  // 單邊比例
  const bigCount=seq.filter(x=>x===1).length;
  const ratio=bigCount/seq.length;

  if(ratio>=0.7 || ratio<=0.3){
    trendScore+=0.5;
  }

  return trendScore;
}

// ==============================
// 核心計算
// ==============================

function calculateSpecial(){

  const gap=getGap();
  let weight=1;

  // ① 週期高斯
  [1,3,5,10,14,16,18].forEach(p=>{
    weight += Math.exp(-((gap-p)**2)/7)*0.7;
  });

  // ② 長間隔拉升
  if(gap>20){
    weight += 0.4 + (gap-20)*0.03;
  }

  // 小gap抑制
  if(gap<3){
    weight*=0.75;
  }

  // ③ 近三局結構
  const last3=rounds.slice(-3);
  let structureBonus=0;

  if(last3.length===3){

    const types=last3.map(r=>analyzeRound(r));

    const tripleCount=types.filter(t=>t===3).length;
    const doubleCount=types.filter(t=>t===2).length;

    // 333
    if(tripleCount===3){
      structureBonus+=1.1;
    }
    // 3321
    else if(tripleCount===2 && doubleCount===1){
      structureBonus+=0.85;
    }
    // 2221
    else if(doubleCount===3){
      structureBonus+=0.6;
    }
    else if(doubleCount===2){
      structureBonus+=0.35;
    }
  }

  weight+=structureBonus;

  // ④ 大小趨勢影響
  weight*=analyzeBigSmallTrend();

  // ⑤ 過熱冷卻
  const recentSpecial=rounds.slice(-6).filter(r=>r.isSpecial).length;
  if(recentSpecial>=2){
    weight*=0.78;
  }

  // ⑥ 基準回歸
  const recent=specialProbs.slice(-10).map(p=>parseFloat(p));
  if(recent.length>=5){
    const avg=recent.reduce((a,b)=>a+b,0)/recent.length;
    if(avg>9){
      weight*=0.88;
    }
  }

  let prob=BASE_SPECIAL*weight;

  if(prob>0.16) prob=0.16;
  if(prob<0.025) prob=0.025;

  specialProbs.push((prob*100).toFixed(2));

  // 顏色
  let color="cold";
  if(prob>0.115) color="hot";
  else if(prob>0.075) color="warm";

  const el=document.getElementById("specialProb");
  el.className="prob "+color;
  el.innerText=(prob*100).toFixed(2)+"%";

  document.getElementById("gapInfo").innerText="目前間隔："+gap;
  document.getElementById("gapHistory").innerText=
    "歷史間隔："+specialIntervals.slice(-10).reverse().join(" → ");
}

// ==============================
// 測試用隨機產生
// ==============================

function addRandom(){

  const d1=Math.ceil(Math.random()*6);
  const d2=Math.ceil(Math.random()*6);
  const d3=Math.ceil(Math.random()*6);

  const total=d1+d2+d3;

  const isSpecial=(d1===d2 && d2===d3);

  rounds.push({d1,d2,d3,total,isSpecial});

  if(isSpecial){
    const gap=getGap();
    specialIntervals.push(gap);
  }

  calculateSpecial();
}

</script>
</body>
</html>
