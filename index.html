<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>è³“æœ 1-99 é æ¸¬å™¨ v2ï¼ˆç†±è™ŸæŠ‘åˆ¶ï¼‹å€æ®µé…æ¯”ï¼‹é¿å…è¿‘NæœŸï¼‰</title>
<style>
body{background:#0f172a;color:#e5e7eb;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial;margin:0;padding:16px;}
.card{background:#111827cc;padding:14px;border-radius:16px;margin-bottom:12px;box-shadow:0 10px 25px rgba(15,23,42,.6);}
.btn{padding:8px 12px;border-radius:999px;border:0;background:linear-gradient(135deg,#22d3ee,#60a5fa);color:#020617;font-weight:700;cursor:pointer;}
.btn.sec{background:#020617;color:#e5e7eb;border:1px solid rgba(148,163,184,.25);}
input,textarea,select{width:100%;padding:10px;border-radius:10px;border:1px solid rgba(148,163,184,.25);background:#020617;color:#e5e7eb;box-sizing:border-box;}
.row{display:flex;flex-wrap:wrap;gap:10px;align-items:center;margin-top:4px;}
.divider{border-top:1px dashed rgba(148,163,184,.4);margin:2px 0;}
.mono{white-space:pre-wrap;font-family:ui-monospace,Consolas,monospace;}
label.switch{display:inline-block;font-size:13px;vertical-align:middle;margin:0;padding:0;}
label.switch input{margin-right:4px;vertical-align:middle;}
#strictWrap,#hotWrap{display:inline-block;font-size:13px;margin:0;padding:0;}
#strictWrap input,#hotWrap input{margin-right:3px;vertical-align:middle;}
.split2{display:flex;gap:8px;}
.split2>div{flex:1;display:flex;flex-direction:column;}
#singleTop .chip,#toplist .chip{margin:1px 0;}
.chip{background:#1e293b;border-radius:12px;padding:6px 8px;font-size:13px;border:1px solid rgba(148,163,184,.35);box-shadow:0 4px 10px rgba(15,23,42,.8);display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;}
.chip span.label{color:#e5e7eb;}
.chip span.value{font-weight:700;}
.chip.rankTop{border-color:#38bdf8;box-shadow:0 0 0 1px rgba(56,189,248,.4),0 10px 25px rgba(15,23,42,.9);background:radial-gradient(circle at top,#0ea5e944,#020617);}
.chip.rankTop span.value{color:#7dd3fc;}
.hit-table-wrapper{max-height:260px;overflow:auto;border-radius:10px;border:1px solid rgba(148,163,184,.4);background:#020617;}
.hit-table{width:100%;border-collapse:collapse;font-size:12px;min-width:680px;}
.hit-table thead{position:sticky;top:0;background:#020617;z-index:1;}
.hit-table th,.hit-table td{padding:6px 8px;text-align:left;border-bottom:1px solid rgba(30,64,175,.5);}
.hit-table th{color:#bfdbfe;font-weight:600;}
.hit-table tr:hover{background:#0b1120;}
.smallnote{font-size:12px;color:#9ca3af;}
</style>
</head>
<body>
<h1>è³“æœ 1-99 é æ¸¬å™¨ v2</h1>

<div id="stats" style="color:#60a5fa;font-size:13px;line-height:1.4;margin-bottom:8px"></div>
<div class="smallnote" style="margin-bottom:10px">
  v2 é‡é»ï¼šåŠ å…¥ã€Œè¿‘æœŸç†±è™ŸæŠ‘åˆ¶ã€ã€ã€Œå€æ®µé…æ¯”æŠ½æ¨£ã€ã€ã€Œé¿å…è¿‘ N æœŸé‡è¤‡ã€ã€‚
  Top10 é¡¯ç¤ºç‚º 0â€“100 åˆ†æ•¸ï¼ˆåƒ…ç”¨æ–¼ç›¸å°æ’åï¼‰ã€‚
</div>

<div class="card">
  <label>è¡°æ¸›æ¬Šé‡ rï¼ˆå»ºè­° 0.95ï½0.98 é™ä½è¿½ç†±ï¼‰</label>
  <div class="row">
    <input id="r" type="number" step="0.01" value="0.95" min="0" max="1" style="max-width:110px">
    <button class="btn sec" type="button" onclick="setR(0.90)">r=0.90</button>
    <button class="btn sec" type="button" onclick="setR(0.95)">r=0.95</button>
    <button class="btn sec" type="button" onclick="setR(0.98)">r=0.98</button>
  </div>

  <div class="row" style="margin-top:10px">
    <label class="switch"><input type="checkbox" id="streak" checked> ğŸ” ç†±è™Ÿé€£é–‹æ‡²ç½°</label>
    <label class="switch"><input type="checkbox" id="neighbor" checked> Â±2 é„°è¿‘åŠ æ¬Š</label>
  </div>

  <div class="row" style="margin-top:6px">
    <label class="switch"><input type="checkbox" id="avoidRecent" checked onchange="toggleStrict()"> é¿å…é‡è¤‡æœ€è¿‘</label>
    <select id="avoidN" onchange="toggleStrict()" style="width:auto">
      <option value="1">1 æœŸ</option>
      <option value="2" selected>2 æœŸ</option>
      <option value="3">3 æœŸ</option>
    </select>
    <label id="strictWrap"><input type="checkbox" id="strictRepeat"> åš´æ ¼æ’é™¤ï¼ˆé‡è¤‡ â‰¥2 é¡†ç›´æ¥å‰ƒé™¤ï¼‰</label>
  </div>

  <div class="row" style="margin-top:6px">
    <label class="switch"><input type="checkbox" id="hotSuppress" checked onchange="toggleHot()"> ğŸ”¥ è¿‘æœŸç†±è™ŸæŠ‘åˆ¶</label>
    <span id="hotWrap">
      å¼·åº¦
      <select id="hotStrength" style="width:auto">
        <option value="0.45">å¼·ï¼ˆÃ—0.45ï¼‰</option>
        <option value="0.60" selected>ä¸­ï¼ˆÃ—0.60ï¼‰</option>
        <option value="0.75">å¼±ï¼ˆÃ—0.75ï¼‰</option>
      </select>
      ä½œç”¨ç¯„åœ
      <select id="hotWindow" style="width:auto">
        <option value="1">æœ€è¿‘ 1 æœŸ</option>
        <option value="2" selected>æœ€è¿‘ 2 æœŸ</option>
        <option value="3">æœ€è¿‘ 3 æœŸ</option>
      </select>
    </span>
  </div>

  <div class="divider" style="margin:10px 0"></div>
  <label>å€æ®µé…æ¯”ï¼ˆæŠ½æ¨£æ™‚å›ºå®šçµæ§‹ï¼Œé¿å…æ•´çµ„é»åœ¨ç†±å€ï¼‰</label>
  <div class="row">
    <select id="segmentPreset" style="width:auto">
      <option value="1-3-1" selected>1-33:1 é¡†ï½œ34-66:3 é¡†ï½œ67-99:1 é¡†ï¼ˆ1-3-1ï¼‰</option>
      <option value="1-2-2">1-33:1 é¡†ï½œ34-66:2 é¡†ï½œ67-99:2 é¡†ï¼ˆ1-2-2ï¼‰</option>
      <option value="2-2-1">1-33:2 é¡†ï½œ34-66:2 é¡†ï½œ67-99:1 é¡†ï¼ˆ2-2-1ï¼‰</option>
      <option value="free">ä¸é™åˆ¶ï¼ˆè‡ªç”±æŠ½æ¨£ï¼‰</option>
    </select>
  </div>

  <div class="divider" style="margin:10px 0"></div>
  <label>æˆ‘çš„ä¸‹æ³¨ï¼ˆäº”é¡†ä¸€çµ„ï¼Œæ¯è¡Œä¸€çµ„ï¼‰</label>
  <textarea id="bets" placeholder="ä¾‹å¦‚ï¼š24 34 58 67 84&#10;8 29 50 69 92"></textarea>

  <div class="row" style="margin-top:8px">
    <button class="btn" type="button" onclick="run()">è¨ˆç®—/é æ¸¬</button>
  </div>

  <div class="divider" style="margin:10px 0"></div>
  <label>æ–°å¢æœ€æ–°ä¸€æœŸï¼ˆäº”é¡†ï¼‰</label>
  <input id="latest" placeholder="ä¾‹å¦‚ï¼š27 35 37 43 71">
  <div class="row">
    <button class="btn" type="button" onclick="appendLatest()">ï¼‹ åŠ å…¥åˆ°æ­·å²</button>
    <button class="btn sec" type="button" onclick="clearAdded()">é‡ç½®æœ¬æ©Ÿæ–°å¢</button>
  </div>

  <div class="divider" style="margin:10px 0"></div>
  <label>æŠ½æ¨£æ¬¡æ•¸ï¼ˆè¶Šå¤§è¶Šæº–ï¼Œä½†è¶Šæ…¢ï¼‰</label>
  <input id="samples" type="number" value="60000" min="2000" step="2000" style="max-width:170px">
  <div class="row" style="margin-top:10px">
    <div style="flex:1;min-width:260px">
      <label>å¹³æ»‘åº•æ¬Šé‡ Î±ï¼ˆè®“æ²’é–‹éçš„è™Ÿç¢¼ä¹Ÿæœ‰æ©Ÿæœƒï¼‰</label>
      <input id="alpha" type="number" value="0.35" min="0" step="0.05" style="max-width:170px">
      <div class="smallnote">Î±=0 ä»£è¡¨å®Œå…¨ä¸çµ¦æœªå‡ºç¾è™Ÿç¢¼æ©Ÿæœƒï¼›å»ºè­° 0.2ï½0.8ã€‚</div>
    </div>
    <div style="flex:1;min-width:260px">
      <label>æ¢ç´¢æ¯”ä¾‹ Îµï¼ˆæ··å…¥å‡å‹»åˆ†å¸ƒï¼Œé¿å…åªè¿½æ­·å²ï¼‰</label>
      <input id="eps" type="number" value="0.25" min="0" max="0.8" step="0.05" style="max-width:170px">
      <div class="smallnote">æœ€çµ‚æ©Ÿç‡ = (1-Îµ)Ã—æ¨¡å‹ + ÎµÃ—å‡å‹»ï¼ˆ1/99ï¼‰ã€‚å»ºè­° 0.15ï½0.35ã€‚</div>
    </div>
  </div>

</div>

<div class="card">
  <h3>ğŸ”¢ å„è™Ÿç¢¼æ©Ÿç‡åˆ†ä½ˆï¼ˆTop10ï¼‰</h3>
  <div class="smallnote">å–®è™Ÿå¹³å‡ç†è«–æ©Ÿç‡ï¼šç´„ 5.05%ï¼ˆå®Œå…¨éš¨æ©Ÿï¼š5/99ï¼‰</div>
  <div id="singleTop" class="mono split2" style="margin-top:6px;">
    <div style="grid-column:1 / -1;font-size:13px;color:#9ca3af">å°šæœªè¨ˆç®—ï¼Œè«‹å…ˆæŒ‰ã€Œè¨ˆç®—/é æ¸¬ã€ã€‚</div>
  </div>
</div>

<div class="card">
  <h3>ğŸ’¡ æœ€æ–°æ¨è–¦çµæœï¼ˆTop1ï½Top10ï¼Œäº”é¡†ï¼‰</h3>
  <div class="smallnote">Top10 ä¾ã€ŒæŠ½æ¨£å‡ºç¾ç‡ã€æ’åºï¼ˆè¿‘ä¼¼ç›¸å°æ©Ÿç‡ï¼‰ï¼›åŒæ™‚æä¾›åˆ†æ•¸ 0â€“100 ä½œç‚ºè¼”åŠ©ã€‚</div>
  <div id="toplist" class="mono split2" style="margin-top:6px;"></div>
</div>

<div class="card">
  <h3>ğŸ“Š å„æ•¸å­—ç´¯è¨ˆé–‹å‡ºæ¬¡æ•¸ï¼ˆå«æœ¬æ©Ÿæ–°å¢ï¼‰</h3>
  <div class="smallnote">ç‚ºé¿å…ç•«é¢éé•·ï¼Œåƒ…é¡¯ç¤ºå‡ºç¾æ¬¡æ•¸ Top10ã€‚</div>
  <div id="countGrid" class="mono split2" style="margin-top:6px;"></div>
  <div id="countSummary" class="smallnote" style="margin-top:4px"></div>
</div>

<div class="card">
  <h3>æˆ‘çš„ä¸‹æ³¨çµæœ</h3>
  <div class="smallnote">é¡¯ç¤ºåŒä¸€å¥—åˆ†æ•¸è¦å‰‡ä¸‹çš„ç›¸å°åˆ†æ•¸ï¼ˆ0â€“100ï¼Œä»¥ä¸Šæ¬¡ Top10 çš„ min/max æ­£è¦åŒ–ï¼‰ã€‚</div>
  <div id="myres" class="mono" style="font-size:13px;color:#94a3b8">å°šæœªè¨ˆç®—</div>
</div>

<div class="card">
  <h3>ğŸ“ˆ å‘½ä¸­ç´€éŒ„è¡¨ï¼ˆå›æ¸¬ï¼šä»¥ TopN é æ¸¬ä¸‹ä¸€æœŸï¼‰</h3>
  <div class="smallnote" style="margin-bottom:6px">
    å›æ¸¬æ¡ç”¨å‰
    <select id="topN" onchange="run()" style="width:auto;display:inline-block;background:#020617;color:#e5e7eb;border:1px solid rgba(148,163,184,.6);border-radius:999px;padding:2px 10px;font-size:12px;margin:0 4px;">
      <option value="1">1</option>
      <option value="3" selected>3</option>
      <option value="5">5</option>
      <option value="10">10</option>
    </select>
    çµ„ï¼ˆç”¨ç•¶æœŸ TopN å»é æ¸¬ä¸‹ä¸€æœŸï¼‰
  </div>
  <div id="hitSummary" class="smallnote" style="margin-bottom:4px">å°šæœªå›æ¸¬ã€‚è«‹å…ˆæŒ‰ã€Œè¨ˆç®—/é æ¸¬ã€ã€‚</div>
  <div class="hit-table-wrapper">
    <table class="hit-table" id="hitTable">
      <thead>
        <tr>
          <th>æœŸæ•¸</th>
          <th>æ—¥æœŸ</th>
          <th>é–‹çè™Ÿç¢¼</th>
          <th>æœ€ä½³å‘½ä¸­</th>
          <th>å‘½ä¸­çµ„åˆï¼ˆæœ€ä½³ï¼‰</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>
</div>

<script>
const N_NUM = 99;
const DRAW_K = 5;

// --- Deterministic RNG (Mulberry32) for stable backtests ---
function mulberry32(seed){
  let t = seed >>> 0;
  return function(){
    t += 0x6D2B79F5;
    let x = Math.imul(t ^ (t >>> 15), 1 | t);
    x ^= x + Math.imul(x ^ (x >>> 7), 61 | x);
    return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
  };
}
// Cheap string->uint32 hash for seeding (FNV-1a)
function hash32(str){
  let h = 2166136261;
  for(let i=0;i<str.length;i++){
    h ^= str.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return h >>> 0;
}


// ç¬¬ 1 æœŸæ—¥æœŸï¼ˆä½ æŒ‡å®šï¼‰
const START_DATE = new Date(2025, 11, 16); // 11=12æœˆ

// å…§å»ºæ­·å²ï¼ˆå·²åŠ å…¥ä½ æä¾›çš„ 7 æœŸï¼‰
const baseHistory = [[18, 48, 69, 91, 13], [53, 56, 49, 37, 20], [21, 82, 45, 20, 71], [54, 77, 18, 20, 66], [42, 33, 39, 35, 21], [22, 62, 99, 45, 64], [89, 33, 68, 4, 92], [17, 70, 75, 73, 36], [49, 83, 88, 72, 93], [91, 92, 24, 65, 95], [33, 97, 71, 84, 99], [32, 87, 44, 88, 69], [62, 11, 41, 95, 80], [72, 58, 20, 89, 63], [22, 53, 11, 56, 07]];

const LS_KEY = "bingo_extraHist_v2";
let added = JSON.parse(localStorage.getItem(LS_KEY) || "[]");

function toggleStrict(){
  const on = document.getElementById("avoidRecent").checked;
  document.getElementById("strictWrap").style.display = on ? "inline-block" : "none";
  document.getElementById("avoidN").disabled = !on;
}
function toggleHot(){
  const on = document.getElementById("hotSuppress").checked;
  document.getElementById("hotWrap").style.display = on ? "inline-block" : "none";
}
toggleStrict();
toggleHot();

function setR(v){ document.getElementById("r").value = v; }
function getAll(){ return baseHistory.concat(added); }

function getIssueDate(issue){ // issue: 1-based
  const d = new Date(START_DATE.getTime());
  d.setDate(d.getDate() + (issue - 1));
  const y = d.getFullYear();
  const m = String(d.getMonth() + 1).padStart(2,"0");
  const dd = String(d.getDate()).padStart(2,"0");
  return `${y}/${m}/${dd}`;
}

function appendLatest(){
  const v = document.getElementById("latest").value.trim().split(/\s+/).map(Number);
  if(v.length===DRAW_K && v.every(n=>Number.isFinite(n) && n>=1 && n<=N_NUM)){
    const uniq=[...new Set(v)];
    if(uniq.length!==DRAW_K){ alert("åŒä¸€æœŸè™Ÿç¢¼ä¸å¯é‡è¤‡"); return; }
    added.push(uniq);
    localStorage.setItem(LS_KEY, JSON.stringify(added));
    updateStats();
    alert("å·²åŠ å…¥ï¼");
    document.getElementById("latest").value="";
  }else{
    alert(`è«‹è¼¸å…¥ ${DRAW_K} å€‹ 1~${N_NUM} çš„æ•¸å­—`);
  }
}
function clearAdded(){
  if(confirm("ç¢ºå®šæ¸…é™¤æœ¬æ©Ÿæ–°å¢ï¼Ÿ")){
    added=[];
    localStorage.removeItem(LS_KEY);
    updateStats();
  }
}

function updateStats(){
  const histAll=getAll();
  const total=histAll.length;
  const latest=(histAll[total-1]||[]).join(" ");
  const latestDate = total ? getIssueDate(total) : "â€”";
  document.getElementById("stats").innerHTML =
    `ğŸ“Š ç›®å‰å…±æœ‰ ${total} æœŸï¼ˆå« ${added.length} æœŸæœ¬æ©Ÿæ–°å¢ï¼‰<br>æœ€æ–°ä¸€æœŸï¼ˆ${latestDate}ï¼‰ï¼š${latest||"â€”"}`;
  const counts=tallyCounts(histAll);
  renderCounts(counts,histAll);
}
updateStats();

// æ¬Šé‡ï¼šr è¡°æ¸› + é€£é–‹/ä¹…æœª é–‹çå¾®èª¿
function singleProbsByR(hist,r,sp,alpha){
  const base = Number.isFinite(alpha) ? Math.max(0, alpha) : 0;
  const w=Array(N_NUM).fill(base), n=hist.length;
  for(let i=0;i<n;i++){
    const ww=Math.pow(r,n-1-i);
    for(const x of hist[i]) w[x-1]+=ww;
  }
  if(sp && n>0){
    for(let num=1;num<=N_NUM;num++){
      let streak=0, miss=0, maxStreak=0, maxMiss=0;
      for(let i=0;i<n;i++){
        if(hist[i].includes(num)){ streak++; maxStreak=Math.max(maxStreak,streak); miss=0; }
        else{ miss++; maxMiss=Math.max(maxMiss,miss); streak=0; }
      }
      if(maxStreak>=3) w[num-1]*=0.88;
      if(maxStreak>=4) w[num-1]*=0.78;
      if(maxMiss>=10)  w[num-1]*=1.08;
      if(maxMiss>=15)  w[num-1]*=1.15;
    }
  }
  const s=w.reduce((a,b)=>a+b,0) || 1;
  return w.map(v=>v/s);
}

// è¿‘æœŸç†±è™ŸæŠ‘åˆ¶ï¼ˆæœ€è¿‘ window æœŸå‡ºç¾ -> æ¬Šé‡ä¹˜ strengthï¼‰
function applyHotSuppression(probs,hist,window,strength){
  const n=hist.length;
  if(n===0) return probs.slice();
  const start=Math.max(0,n-window);
  const hot=new Set();
  for(let i=start;i<n;i++) for(const x of hist[i]) hot.add(x);

  const out=probs.slice();
  for(const x of hot) out[x-1]*=strength;

  const s=out.reduce((a,b)=>a+b,0) || 1;
  return out.map(v=>v/s);
}

// é„°è¿‘åŠ æ¬Šï¼šæœ€è¿‘ä¸€æœŸ Â±2 å°å¹…åŠ æ¬Š
function applyNeighborBoost(probs,hist){
  const n=hist.length;
  if(n===0) return probs.slice();
  const last=hist[n-1];
  const boosted=probs.slice();
  const boost1=1.06, boost2=1.03;
  for(const x of last){
    for(const d of [-2,-1,1,2]){
      const y=x+d;
      if(y>=1 && y<=N_NUM) boosted[y-1]*=(Math.abs(d)===1?boost1:boost2);
    }
  }
  const s=boosted.reduce((a,b)=>a+b,0) || 1;
  return boosted.map(v=>v/s);
}

// é¿å…è¿‘ N æœŸé‡è¤‡
function countOverlap(combo, hist, nWindow){
  if(!hist.length) return 0;
  const n=hist.length;
  const start=Math.max(0,n-nWindow);
  const recent=new Set();
  for(let i=start;i<n;i++) for(const x of hist[i]) recent.add(x);
  return combo.filter(x=>recent.has(x)).length;
}

function scoreCombo(combo, probs, hist, avoidOn, avoidN, strict){
  let sc=0;
  for(const x of combo){
    const p=probs[x-1] || 1e-12;
    sc += Math.log(p);
  }

  const sorted=[...combo].sort((a,b)=>a-b);
  let adj=0;
  for(let i=1;i<sorted.length;i++) if(sorted[i]-sorted[i-1]===1) adj++;
  if(adj>=2) sc -= 0.22;
  if(adj>=3) sc -= 0.55;

  const spread=sorted[sorted.length-1]-sorted[0];
  if(spread<=14) sc -= 0.22;

  if(avoidOn && hist.length){
    const same=countOverlap(sorted,hist,avoidN);
    if(strict && same>=2) return -Infinity;
    if(same===1) sc -= 0.12;
    if(same===2) sc -= 0.32;
    if(same===3) sc -= 0.80;
    if(same===4) sc -= 1.60;
    if(same>=5) sc -= 2.50;
  }
  return sc;
}

// CDF / ä¾å€æ®µæŠ½æ¨£
function makeCDF(probs, lo, hi){
  const items=[];
  for(let x=lo;x<=hi;x++) items.push({x, p: Math.max(probs[x-1], 1e-12)});
  let s=0;
  for(const it of items) s+=it.p;
  let c=0;
  const cdf=[];
  for(const it of items){
    c += it.p/s;
    cdf.push({x:it.x, c});
  }
  return cdf;
}
function sampleFromCDF(cdf, rng){
  const u=(rng? rng(): Math.random());
  for(const it of cdf) if(u<=it.c) return it.x;
  return cdf[cdf.length-1].x;
}

function sampleSegmented(probs, preset, rng){
  let lowN=0, midN=0, highN=0;
  if(preset==="1-3-1"){ lowN=1; midN=3; highN=1; }
  else if(preset==="1-2-2"){ lowN=1; midN=2; highN=2; }
  else if(preset==="2-2-1"){ lowN=2; midN=2; highN=1; }
  else return weightedSampleWithoutReplacement(probs, DRAW_K, rng);

  const cdfL=makeCDF(probs,1,33);
  const cdfM=makeCDF(probs,34,66);
  const cdfH=makeCDF(probs,67,99);

  const chosen=new Set();
  function pick(cdf, need){
    while(need>0){
      const x=sampleFromCDF(cdf, rng);
      if(!chosen.has(x)){ chosen.add(x); need--; }
    }
  }
  pick(cdfL, lowN);
  pick(cdfM, midN);
  pick(cdfH, highN);

  return Array.from(chosen).sort((a,b)=>a-b);
}

// ä¸æ”¾å›æŠ½æ¨£ï¼škey=log(u)/w
function weightedSampleWithoutReplacement(probs, k, rng){
  const keys=[];
  for(let i=1;i<=N_NUM;i++){
    const w=Math.max(probs[i-1], 1e-12);
    const u=(rng? rng(): Math.random());
    keys.push({num:i, key: Math.log(u)/w});
  }
  keys.sort((a,b)=>b.key-a.key);
  return keys.slice(0,k).map(x=>x.num).sort((a,b)=>a-b);
}

function computeTopCombosBySampling(hist, probs, avoidOn, avoidN, strict, samples, preset, rng){
  // Monte Carlo sampling: count how often each valid combo appears under the sampling policy
  // This "å‡ºç¾ç‡" is a proxy for relative probability under the current model + constraints.
  const counts = new Map();  // key -> {combo, cnt}
  for(let s=0;s<samples;s++){
    const combo = (preset==="free")
      ? weightedSampleWithoutReplacement(probs, DRAW_K, rng)
      : sampleSegmented(probs, preset, rng);

    // Score/constraints
    const sc = scoreCombo(combo, probs, hist, avoidOn, avoidN, strict);
    if(!Number.isFinite(sc)) continue;

    const key = combo.join(",");
    const cur = counts.get(key);
    if(cur) cur.cnt += 1;
    else counts.set(key, {combo, cnt: 1, sc});
  }

  // Build list with estimated frequency
  const arr = [];
  for(const v of counts.values()){
    arr.push({
      combo: v.combo,
      sc: v.sc,
      cnt: v.cnt,
      pEst: v.cnt / samples
    });
  }

  // Rank: primary by estimated frequency, secondary by score
  arr.sort((a,b)=> (b.pEst - a.pEst) || (b.sc - a.sc));
  return arr.slice(0, 10);
}

function updateSingleTop(probs){
  const arr=probs.map((p,i)=>({num:i+1,p})).sort((a,b)=>b.p-a.p).slice(0,10);
  const left=arr.slice(0,5), right=arr.slice(5,10);
  const render=(o,rank)=>{
    const cls=rank<=3?"chip rankTop":"chip";
    return `<div class="${cls}">
      <span class="label">#${rank} è™Ÿç¢¼ ${o.num}</span>
      <span class="value">${(o.p*100).toFixed(3)}%</span>
    </div>`;
  };
  document.getElementById("singleTop").innerHTML =
    `<div>${left.map((o,i)=>render(o,i+1)).join("")}</div><div>${right.map((o,i)=>render(o,i+6)).join("")}</div>`;
}

function tallyCounts(hist){
  const counts=Array(N_NUM).fill(0);
  for(const draw of hist) for(const x of draw) counts[x-1]++;
  return counts;
}

function renderCounts(counts,hist){
  const totalBalls = hist.length * DRAW_K;
  const items = counts.map((c,i)=>({num:i+1,c,p:totalBalls?c/totalBalls:0}))
    .sort((a,b)=>b.c-a.c).slice(0,10);

  const left=items.slice(0,5), right=items.slice(5,10);
  const chipHtml=o=>`
    <div class="chip">
      <span class="label">è™Ÿç¢¼ ${o.num}</span>
      <span class="value">${o.c} æ¬¡ï½œ${(o.p*100).toFixed(2)}%</span>
    </div>`;
  document.getElementById("countGrid").innerHTML =
    `<div>${left.map(chipHtml).join("")}</div><div>${right.map(chipHtml).join("")}</div>`;
  document.getElementById("countSummary").textContent =
    `ç´¯è¨ˆ ${hist.length} æœŸï¼Œå…± ${totalBalls} é¡†æ¬¡ã€‚é¡¯ç¤ºå‡ºç¾æ¬¡æ•¸ Top10ã€‚`;
}

// å›æ¸¬
function backtestTopN(hist, opts){
  const n=hist.length, rows=[];
  if(n<3) return rows;

  for(let i=1;i<n-1;i++){
    const train=hist.slice(0,i+1);
    const target=hist[i+1];

    let probs=singleProbsByR(train, opts.r, opts.streak, opts.alpha);
    if(opts.hotSuppress) probs=applyHotSuppression(probs, train, opts.hotWindow, opts.hotStrength);
    if(opts.neighbor) probs=applyNeighborBoost(probs, train);
    const epsClamped = Number.isFinite(opts.eps) ? Math.max(0, Math.min(0.8, opts.eps)) : 0;
    if(epsClamped>0){
      const uni = 1 / N_NUM;
      probs = probs.map(p => (1 - epsClamped) * p + epsClamped * uni);
      const s = probs.reduce((a,b)=>a+b,0) || 1;
      probs = probs.map(v => v/s);
    }


    // Deterministic seed: stable across UI toggles like TopN (so TopN only slices)
    const seedStr = `${i}|${opts.r}|${opts.streak}|${opts.neighbor}|${opts.avoidOn}|${opts.avoidN}|${opts.strict}|${opts.hotSuppress}|${opts.hotStrength}|${opts.hotWindow}|${opts.preset}|${opts.alpha}|${opts.eps}`;
    const rng = mulberry32(hash32(seedStr));
    const topAll = computeTopCombosBySampling(
      train, probs, opts.avoidOn, opts.avoidN, opts.strict,
      Math.max(12000, Math.floor(opts.samples/5)), opts.preset, rng
    );
    const top = topAll.slice(0, opts.topN);

    let bestHit=0;
    const hitCombos=[];
    for(const item of top){
      const hit=item.combo.filter(x=>target.includes(x)).length;
      if(hit>0) hitCombos.push({combo:item.combo, hit});
      if(hit>bestHit) bestHit=hit;
    }
    rows.push({issue:i+2, date:getIssueDate(i+2), target, bestHit, hitCombos});
  }
  return rows;
}

function renderHits(rows,topN){
  const summary=document.getElementById("hitSummary");
  const tbody=document.querySelector("#hitTable tbody");
  if(!rows.length){
    summary.textContent="æ­·å²æœŸæ•¸ä¸è¶³ï¼Œç„¡æ³•å›æ¸¬ï¼ˆè‡³å°‘éœ€è¦ 3 æœŸï¼‰ã€‚";
    tbody.innerHTML="";
    return;
  }
  const totalAll=rows.length;
  const displayRows= totalAll>30 ? rows.slice(-30) : rows;

  let c5=0,c4=0,c3=0,c2=0,c1=0,c0=0,any=0;
  for(const r of displayRows){
    if(r.bestHit>=1) any++;
    if(r.bestHit===5) c5++; else if(r.bestHit===4) c4++; else if(r.bestHit===3) c3++;
    else if(r.bestHit===2) c2++; else if(r.bestHit===1) c1++; else c0++;
  }
  summary.textContent =
    `å…± ${totalAll} æœŸï¼ˆé¡¯ç¤º ${displayRows.length} æœŸï¼‰ï¼›Top${topN} å›æ¸¬ï¼šè‡³å°‘ä¸­ 1 é¡† ${any} æœŸï¼›ä¸­5:${c5} ä¸­4:${c4} ä¸­3:${c3} ä¸­2:${c2} ä¸­1:${c1} 0ä¸­:${c0}`;

  let html="";
  for(const r of displayRows){
    const issue=`ç¬¬ ${r.issue} æœŸ`;
    const targetStr=r.target.join(" ");
    const hitLabel=r.bestHit?`${r.bestHit} é¡†`:"0 é¡†";
    let comboStr="â€”";
    if(r.hitCombos.length){
      const best=r.bestHit;
      comboStr=r.hitCombos.filter(x=>x.hit===best).map(x=>x.combo.join(" ")).join("ã€");
    }
    html += `<tr>
      <td style="white-space:nowrap;">${issue}</td>
      <td style="white-space:nowrap;">${r.date}</td>
      <td>${targetStr}</td>
      <td>${hitLabel}</td>
      <td style="max-width:360px;word-break:break-all;">${comboStr}</td>
    </tr>`;
  }
  tbody.innerHTML=html;
}

function run(){
  const hist=getAll();

  let r=parseFloat(document.getElementById("r").value);
  if(!Number.isFinite(r) || r<=0 || r>=1){ r=0.95; document.getElementById("r").value="0.95"; }

  const streak=document.getElementById("streak").checked;
  const neighbor=document.getElementById("neighbor").checked;

  const avoidOn=document.getElementById("avoidRecent").checked;
  const avoidN=parseInt(document.getElementById("avoidN").value,10) || 2;
  const strict=document.getElementById("strictRepeat").checked;

  const hotSuppress=document.getElementById("hotSuppress").checked;
  const hotStrength=parseFloat(document.getElementById("hotStrength").value);
  const hotWindow=parseInt(document.getElementById("hotWindow").value,10) || 2;

  const preset=document.getElementById("segmentPreset").value;

  const topN=parseInt(document.getElementById("topN").value,10) || 3;
  const samples=parseInt(document.getElementById("samples").value,10) || 60000;

  const alpha=parseFloat(document.getElementById("alpha").value);
  const eps=parseFloat(document.getElementById("eps").value);


  let probs=singleProbsByR(hist,r,streak,alpha);
  if(hotSuppress) probs=applyHotSuppression(probs,hist,hotWindow,hotStrength);
  if(neighbor) probs=applyNeighborBoost(probs,hist);
  // æ¢ç´¢æ¯”ä¾‹ï¼šæ··å…¥å‡å‹»åˆ†å¸ƒï¼Œé¿å…åªé›†ä¸­åœ¨æ­·å²é–‹éçš„è™Ÿç¢¼
  const epsClamped = Number.isFinite(eps) ? Math.max(0, Math.min(0.8, eps)) : 0;
  if(epsClamped>0){
    const uni = 1 / N_NUM;
    probs = probs.map(p => (1 - epsClamped) * p + epsClamped * uni);
    const s = probs.reduce((a,b)=>a+b,0) || 1;
    probs = probs.map(v => v/s);
  }


  updateSingleTop(probs);

    // Deterministic seed for main recommendations (stable across clicks)
  const lastStr = hist.length ? hist[hist.length-1].join(",") : "";
  const seedStrMain = `${hist.length}|${lastStr}|${r}|${streak}|${neighbor}|${avoidOn}|${avoidN}|${strict}|${hotSuppress}|${hotStrength}|${hotWindow}|${preset}|${samples}|${alpha}|${eps}`;
  const rngMain = mulberry32(hash32(seedStrMain));

const top=computeTopCombosBySampling(hist,probs,avoidOn,avoidN,strict,samples,preset,rngMain);

  const scs=top.map(x=>x.sc);
  const maxSc=Math.max(...scs), minSc=Math.min(...scs);
  const to100=(sc)=>{
    if(maxSc===minSc) return 100;
    const v=(sc-minSc)*100/(maxSc-minSc);
    return Math.max(0,Math.min(100,Math.round(v)));
  };

  const left=top.slice(0,5), right=top.slice(5,10);
  const renderCombo=(o,rank)=>{
    const cls=rank<=3?"chip rankTop":"chip";
    return `<div class="${cls}">
      <span class="label">Top${rank}ï½œ${o.combo.join(" ")}</span>
      <span class="value">å‡ºç¾ç‡ ${ (o.pEst*100).toFixed(2) }%ï½œåˆ†æ•¸ ${to100(o.sc)}/100</span>
    </div>`;
  };
  document.getElementById("toplist").innerHTML =
    `<div>${left.map((o,i)=>renderCombo(o,i+1)).join("")}</div><div>${right.map((o,i)=>renderCombo(o,i+6)).join("")}</div>`;

  const bets=document.getElementById("bets").value.trim();
  if(!bets){
    document.getElementById("myres").textContent="å°šæœªè¼¸å…¥ä¸‹æ³¨ã€‚";
  }else{
    const lines=bets.split(/\n+/).map(l=>l.trim()).filter(Boolean);
    const res=[];
    for(const l of lines){
      const arr=l.split(/\s+/).map(Number).filter(n=>Number.isFinite(n));
      if(arr.length!==DRAW_K){ res.push(`${l} â†’ æ ¼å¼éŒ¯èª¤`); continue; }
      const uniq=[...new Set(arr)];
      if(uniq.length!==DRAW_K){ res.push(`${l} â†’ å…§å«é‡è¤‡è™Ÿç¢¼`); continue; }
      const combo=uniq.sort((a,b)=>a-b);

      const sc=scoreCombo(combo,probs,hist,avoidOn,avoidN,strict);
      const key=combo.join(",");
      const idx=top.findIndex(x=>x.combo.join(",")===key);
      const rankText=idx>=0?`ï¼ˆTop${idx+1}ï½œå‡ºç¾ç‡ ${(top[idx].pEst*100).toFixed(2)}%ï¼‰`:"";
      res.push(`${combo.join(" ")} â†’ åˆ†æ•¸ ${to100(sc)}/100 ${rankText}`);
    }
    document.getElementById("myres").textContent=res.join("\n");
  }

  const rows=backtestTopN(hist, {
    r, streak, neighbor,
    avoidOn, avoidN, strict,
    hotSuppress, hotStrength, hotWindow,
    preset, topN, samples, alpha, eps
  });
  renderHits(rows, topN);

  updateStats();
}
</script>
</body>
</html>
